ljmp start

P5 equ 0F8H
P7 equ 0DBH
	
LCDstatus  equ 0FF2EH       ; adres do odczytu gotowosci LCD
LCDcontrol equ 0FF2CH       ; adres do podania bajtu sterujacego LCD
LCDdataWR  equ 0FF2DH       ; adres do podania kodu ASCII na LCD

// bajty sterujace LCD, inne dostepne w opisie LCD na stronie WWW
#define  HOME     0x80     // put cursor to second line  
#define  INITDISP 0x38     // LCD init (8-bit mode)  
#define  HOM2     0xc0     // put cursor to second line  
#define  LCDON    0x0e     // LCD nn, cursor off, blinking off
#define  CLEAR    0x01     // LCD display clear

// linie klawiatury - sterowanie na port P5
#define LINE_1		0x7f	// 0111 1111
#define LINE_2		0xbf	// 1011 1111
#define	LINE_3		0xdf	// 1101 1111
#define LINE_4		0xef	// 1110 1111
#define ALL_LINES	0x0f	// 0000 1111

ORG 000BH     				; obsluga przerwania
	MOV TH0, #3CH 			; przeladowanie
	MOV TL0, #0B0H 			; stalej timera na 50ms
	DEC R0        			; korekta licznika
	RETI          			; powr?t z przerwania

org 0100H
		
// macro do wprowadzenia bajtu sterujacego na LCD
LCDcntrlWR MACRO x          ; x ? parametr wywolania macra ? bajt sterujacy
           LOCAL loop       ; LOCAL oznacza ze etykieta loop moze sie powt?rzyc w programie
loop: MOV  DPTR,#LCDstatus  ; DPTR zaladowany adresem statusu
      MOVX A,@DPTR          ; pobranie bajtu z biezacym statusem LCD
      JB   ACC.7,loop       ; testowanie najstarszego bitu akumulatora
                            ; ? wskazuje gotowosc LCD
      MOV  DPTR,#LCDcontrol ; DPTR zaladowany adresem do podania bajtu sterujacego
      MOV  A, x             ; do akumulatora trafia argument wywolania macra?bajt sterujacy
      MOVX @DPTR,A          ; bajt sterujacy podany do LCD ? zadana akcja widoczna na LCD
      ENDM
	  
// macro do wypisania znaku ASCII na LCD, znak ASCII przed wywolaniem macra ma byc w A
LCDcharWR MACRO
      LOCAL tutu            ; LOCAL oznacza ze etykieta tutu moze sie powt?rzyc w programie
      PUSH ACC              ; odlozenie biezacej zawartosci akumulatora na stos
tutu: MOV  DPTR,#LCDstatus  ; DPTR zaladowany adresem statusu
      MOVX A,@DPTR          ; pobranie bajtu z biezacym statusem LCD
      JB   ACC.7,tutu       ; testowanie najstarszego bitu akumulatora
                            ; ? wskazuje gotowosc LCD
      MOV  DPTR,#LCDdataWR  ; DPTR zaladowany adresem do podania bajtu sterujacego
      POP  ACC              ; w akumulatorze ponownie kod ASCII znaku na LCD
      MOVX @DPTR,A          ; kod ASCII podany do LCD ? znak widoczny na LCD
      ENDM
	  
// macro do inicjalizacji wyswietlacza ? bez parametr?w
init_LCD MACRO
         LCDcntrlWR #INITDISP ; wywolanie macra LCDcntrlWR ? inicjalizacja LCD
         LCDcntrlWR #CLEAR    ; wywolanie macra LCDcntrlWR ? czyszczenie LCD
         LCDcntrlWR #LCDON    ; wywolanie macra LCDcntrlWR ? konfiguracja kursora
         ENDM
		 
// funkcja wypisania liczby dla potrzeb zegara
putdigitLCD:	mov b, #10
				div ab				; uzyskanie cyfry dziesiatek
				add a, #30H			; konwersja cyfry na kod ASCII
				acall putcharLCD
				mov a, b			; ladowanie cyfry jednosci
				add a, #30H			; konwersja na LCD
				acall putcharLCD
				ret

// funkcaj wypisywania znaku na LCD
putcharLCD:	LCDcharWR
			ret
		 

// wyznaczanie biezacej wartosci zegara i jego wyswietlanie na LCD
ZEGAR:		INC R7				; licznik sekund
			MOV A, R7			; obsluga sekund
			CLR C
			SUBB A, #60			; przepelnienie sekund
			JZ MINUTY
			LCDcntrlWR #HOME	; wyswietlenie calego zegara
			MOV A, R5			; godziny
			ACALL putdigitLCD
			MOV A, #":"			; separator
			ACALL putcharLCD
			MOV A, R6			; minuty
			ACALL putdigitLCD
			MOV A, #":"			; separator
			ACALL putcharLCD
			MOV A, R7			; sekundy
			ACALL putdigitLCD
			JMP FINAL
MINUTY:		MOV R7, #00H		; zerowanie sekund
			INC R6				; licznik minut
			MOV A, R6			; obsluga minut
			CLR C
			SUBB A, #60			; przepelnienie minut
			JZ GODZINY
			LCDcntrlWR #HOME	; wyswietlenie calego zegara
			MOV A, R5			; godziny
			ACALL putdigitLCD
			MOV A, #":"			; separator
			ACALL putcharLCD
			MOV A, R6			; minuty
			ACALL putdigitLCD
			MOV A, #":"			; separator
			ACALL putcharLCD
			MOV A, R7			; sekundy
			ACALL putdigitLCD
			JMP FINAL
GODZINY:	MOV R6, #00H		; zerowanie minut
			INC R5				; licznik godzin
			MOV A, R5
			CLR C
			SUBB A, #24			; przepelenienie godzin - doba
			JNZ EKRAN
			MOV R5, #00H		; zerowanie godzin
EKRAN:		LCDcntrlWR #HOME	; wyswietlenie calego zegara
			MOV A, R5			; godziny
			ACALL putdigitLCD
			MOV A, #":"			; separator
			ACALL putcharLCD
			MOV A, R6			; minuty
			ACALL putdigitLCD
			MOV A, #":"			; separator
			ACALL putcharLCD
			MOV A, R7			; sekundy
			ACALL putdigitLCD
FINAL:		RET


stopTimer:
	  clr TR0
	  ret
startTimer:
	setb TR0
	ret
resetTimer:
	mov r5, #0H
	mov r6, #0H
	MOV R7, #0FFH
	ACALL ZEGAR
	mov r0, #20
	ret


keyascii:	mov dptr, #80EBH
			mov a, #0
			movx @dptr, a
			
			mov dptr, #8077H
			mov a, #1
			movx @dptr, a
			
			mov dptr, #807BH
			mov a, #2
			movx @dptr, a
			
			mov dptr, #807DH
			mov a, #3
			movx @dptr, a
			
			mov dptr, #80B7H
			mov a, #4
			movx @dptr, a
			
			mov dptr, #80BBH
			mov a, #5
			movx @dptr, a
			
			mov dptr, #80BDH
			mov a, #6
			movx @dptr, a
			
			mov dptr, #80D7H
			mov a, #7
			movx @dptr, a
			
			mov dptr, #80DBH
			mov a, #8
			movx @dptr, a
			
			mov dptr, #80DDH
			mov a, #9
			movx @dptr, a
			
			mov dptr, #807EH
			mov a, #"A"
			movx @dptr, a
			
			mov dptr, #80BEH
			mov a, #"B"
			movx @dptr, a
			
			mov dptr, #80DEH
			mov a, #"C"
			movx @dptr, a
			
			mov dptr, #80EEH
			mov a, #"D"
			movx @dptr, a
			
			mov dptr, #80E7H
			mov a, #"*"
			movx @dptr, a
			
			mov dptr, #80EDH
			mov a, #"#"
			movx @dptr, a
			
			ret


	 	delay:		
			mov a, P7
			anl a, r0
			clr c
			subb a, r2
			jz delay
			ret
			
// R5 - wynikowa godzina
// r3 - pomocowy
setHours:
	LCDcntrlWR #CLEAR
	LCDcntrlWR #HOME
	mov r5, #0H
	mov r3, #1H
	key_1h:	mov r0, #LINE_1
			mov	a, r0
			mov	P5, a
			mov a, P7
			anl a, r0
			mov r2, a
			clr c
			subb a, r0
			jz key_2h
			acall delay
			mov a, r2
			mov dph, #80h
			mov dpl, a
			movx a,@dptr
			djnz r3, mniej1//jezeli 0 to bedzie wpisana mniej znaczaca wartosc
			clr c
			mov b, #10
			mul ab
			clr c
			mov r5, a
			sjmp key_2h
			mniej1: 
			clr c
			add a, r5 
			clr c
			mov r5, a
			sjmp checkHours

	key_2h:	mov r0, #LINE_2
			mov	a, r0
			mov	P5, a
			mov a, P7
			anl a, r0
			mov r2, a
			clr c
			subb a, r0
			jz key_3h
			acall delay
			mov a, r2
			mov dph, #80h
			mov dpl, a
			movx a,@dptr
			djnz r3, mniej2//jezeli 0 to bedzie wpisana mniej znaczaca wartosc
			clr c
			mov b, #10
			mul ab
			clr c
			mov r5, a
			sjmp key_3h
			mniej2: 
			clr c
			add a, r5 
			clr c
			mov r5, a
			sjmp checkHours
			
	key_3h:	mov r0, #LINE_3
			mov	a, r0
			mov	P5, a
			mov a, P7
			anl a, r0
			mov r2, a
			clr c
			subb a, r0
			jz key_4h
			acall delay
			mov a, r2
			mov dph, #80h
			mov dpl, a
			movx a,@dptr
			djnz r3, mniej3//jezeli 0 to bedzie wpisana mniej znaczaca wartosc
			clr c
			mov b, #10
			mul ab
			clr c
			mov r5, a
			sjmp key_4h
			mniej3: 
			clr c
			add a, r5 
			clr c
			mov r5, a
			sjmp checkHours
			
	key_4h:	mov r0, #LINE_4
			mov	a, r0
			mov	P5, a
			mov a, P7
			anl a, r0
			mov r2, a
			clr c
			subb a, r0
			jz toTheBeginingH
			acall delay
			mov a, r2
			mov dph, #80h
			mov dpl, a
			movx a,@dptr
			mov P1, a
			djnz r3, mniej4//jezeli 0 to bedzie wpisana mniej znaczaca wartosc
			clr c
			mov b, #10
			mul ab
			clr c
			mov r5, a
			jmp key_1h
			mniej4: 
			clr c
			add a, r5 
			clr c
			mov r5, a
			sjmp checkHours
		
		toTheBeginingH:
			jmp key_1h
	
	checkHours:
		mov a, r5
		acall putdigitLCD
		clr c
		mov a, #24
		subb a, r5
		jc inBetweenHour
		clr c
		mov a, #24
		subb a, r5
		mov r5, a // poniewaz nasz licznik leci w gore to aby odmierzyc x godzin to musimy zaczac od 24-x
		ret
	inBetweenHour:	jmp setHours 

// R6 - wynikowa godzina
// r3 - pomocowy
setMinutes:
	LCDcntrlWR #CLEAR
	LCDcntrlWR #HOME
	mov r6, #0H
	mov r3, #1H
	key_1m:	mov r0, #LINE_1
			mov	a, r0
			mov	P5, a
			mov a, P7
			anl a, r0
			mov r2, a
			clr c
			subb a, r0
			jz key_2m
			acall delay
			mov a, r2
			mov dph, #80h
			mov dpl, a
			movx a,@dptr
			djnz r3, mniej1m//jezeli 0 to bedzie wpisana mniej znaczaca wartosc
			clr c
			mov b, #10
			mul ab
			clr c
			mov r6, a
			sjmp key_2m
			mniej1m: 
			clr c
			add a, r6 
			clr c
			mov r6, a
			sjmp checkMinutes
//						
			
	key_2m:	mov r0, #LINE_2
			mov	a, r0
			mov	P5, a
			mov a, P7
			anl a, r0
			mov r2, a
			clr c
			subb a, r0
			jz key_3m
			acall delay
			mov a, r2
			mov dph, #80h
			mov dpl, a
			movx a,@dptr
			djnz r3, mniej2m//jezeli 0 to bedzie wpisana mniej znaczaca wartosc
			clr c
			mov b, #10
			mul ab
			clr c
			mov r6, a
			sjmp key_3m
			mniej2m: 
			clr c
			add a, r6 
			clr c
			mov r6, a
			sjmp checkMinutes
			
	key_3m:	mov r0, #LINE_3
			mov	a, r0
			mov	P5, a
			mov a, P7
			anl a, r0
			mov r2, a
			clr c
			subb a, r0
			jz key_4m
			acall delay
			mov a, r2
			mov dph, #80h
			mov dpl, a
			movx a,@dptr
			djnz r3, mniej3m//jezeli 0 to bedzie wpisana mniej znaczaca wartosc
			clr c
			mov b, #10
			mul ab
			clr c
			mov r6, a
			sjmp key_4m
			mniej3m: 
			clr c
			add a, r6 
			clr c
			mov r6, a
			sjmp checkMinutes
			
	key_4m:	mov r0, #LINE_4
			mov	a, r0
			mov	P5, a
			mov a, P7
			anl a, r0
			mov r2, a
			clr c
			subb a, r0
			jz toTheBeginingM
			acall delay
			mov a, r2
			mov dph, #80h
			mov dpl, a
			movx a,@dptr
			mov P1, a
			djnz r3, mniej4m//jezeli 0 to bedzie wpisana mniej znaczaca wartosc
			clr c
			mov b, #10
			mul ab
			clr c
			mov r6, a
			jmp key_1m
			mniej4m: 
			clr c
			add a, r6 
			clr c
			mov r6, a
			sjmp checkMinutes
	toTheBeginingM:
			jmp key_1m
		
	checkMinutes:
		mov a, r6
		acall putdigitLCD
		clr c
		mov a, #60
		subb a, r6
		jc inBetweenMinutes
		clr c
		mov a, #60
		subb a, r6
		mov r6, a // poniewaz nasz licznik leci w gore to aby odmierzyc x minut to musimy zaczac od 60-x
		mov a, r6
		jz mEnd
		dec r5 // poniewaz nasz licznik leci w gore to musimy dac poprawke rowniez na godziny, gdy minuty sa rozne od 0
		mEnd:
		ret
	inBetweenMinutes:	jmp setMinutes 

        ; program gl?wny
START:	init_LCD
		acall keyascii
		MOV TMOD, #01H 			; konfiguracja timera
		MOV TH0, #3CH 			; ladowanie
		MOV TL0, #0B0H 			; stalej timera na 50ms
		//SETB TR0      			; timer start
		MOV IE, #82H  			; przerwania wlacz
		acall setHours
			; inicjacja zegara
		acall setMinutes
		MOV R7, #0FFH
		ACALL ZEGAR				; wyswietlenie zainicjowanego zegara
		MOV A, #0FH
		MOV P1, A    			; zapalenie di?d
		MOV R0, #20 
		
					; licznik odmierzen 20 x 50ms
CZEKAM: 				; czekam, a timer
		// 7E - A
		// BE - B
		// DE - C	      	
		key_1:	mov r1, #LINE_1
			mov	a, r1
			mov	P5, a
			mov a, P7
			anl a, r1
			mov r2, a
			clr c
			subb a, r1
			jz key_2
			acall delay
			mov a, r2
			clr c
			subb a, #7EH
			jnz key_2
			acall stopTimer


		key_2:	mov r1, #LINE_2
			mov	a, r1
			mov	P5, a
			mov a, P7
			anl a, r1
			mov r2, a
			clr c
			subb a, r1
			jz key_3
			acall delay
			mov a, r2
		    clr c
			subb a, #0BEH
			jnz key_3
			acall startTimer

			
		key_3:	mov r1, #LINE_3
			mov	a, r1
			mov	P5, a
			mov a, P7
			anl a, r1
			mov r2, a
			clr c
			subb a, r1
			jz checkSeconds
			acall delay
			mov a, r2
			clr c
			subb a, #0DEH
			jnz checkSeconds
			acall resetTimer

	checkSeconds:
		MOV A, R0   
		JNZ CZEKAM   			; mierzy laczny czas 1s
		MOV R0, #20				; po zgloszeniu przerwania - ustawiam na nowo licznik odmierzen 20 x 50ms
		ACALL ZEGAR				; uruchomienie procedury oblugi i wyswietlenia zegara
		MOV A, P1  				; zmiana
		CPL A       			; swiecenia
		MOV P1, A    			; di?d
		JMP CZEKAM    			; czekam na kolejna sekunde
		NOP
		NOP
		NOP
		JMP $
END START
